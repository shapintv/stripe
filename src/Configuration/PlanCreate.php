<?php

declare(strict_types=1);

/*
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file for details.
 */

namespace Shapin\Stripe\Configuration;

use Shapin\Stripe\Model\Plan\Plan;
use Symfony\Component\Config\Definition\Builder\TreeBuilder;
use Symfony\Component\Config\Definition\ConfigurationInterface;

class PlanCreate implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder('shapin_stripe');
        $rootNode = $treeBuilder->getRootNode();

        $rootNode
            ->children()
                ->scalarNode('id')
                    ->info('An identifier randomly generated by Stripe. Used to identify this plan when subscribing a customer. You can optionally override this ID, but the ID must be unique across all plans in your Stripe account. You can, however, use the same plan ID in both live and test modes.')
                ->end()
                ->scalarNode('currency')
                    ->isRequired()
                    ->info('Three-letter ISO currency code, in lowercase. Must be a supported currency.')
                ->end()
                ->enumNode('interval')
                    ->isRequired()
                    ->values([Plan::INTERVAL_DAY, Plan::INTERVAL_WEEK, Plan::INTERVAL_MONTH, Plan::INTERVAL_YEAR])
                    ->info('Specifies billing frequency. Either day, week, month or year.')
                ->end()
                ->scalarNode('existing_product')
                    ->info('The product whose pricing the created plan will represent. This can either be the ID of an existing product, or a dictionary containing fields used to create a service product.')
                ->end()
                ->arrayNode('product')
                    ->children()
                        ->scalarNode('id')
                            ->info('The identifier for the product. Must be unique. If not provided, an identifier will be randomly generated.')
                        ->end()
                        ->scalarNode('name')
                            ->isRequired()
                            ->info('The product’s name, meant to be displayable to the customer.')
                        ->end()
                        ->booleanNode('active')
                            ->info('Whether to immediately capture the charge. When false, the charge issues an authorization (or pre-authorization), and will need to be captured later. Uncaptured charges expire in seven days. For more information, see the authorizing charges and settling later documentation.')
                        ->end()
                        ->arrayNode('metadata')
                            ->scalarPrototype()->end()
                            ->info('Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata.')
                        ->end()
                        ->scalarNode('statement_descriptor')
                            ->info('An arbitrary string to be displayed on your customer’s credit card statement. This may be up to 22 characters. The statement description may not include <>”’ characters, and will appear on your customer’s statement in capital letters. Non-ASCII characters are automatically stripped. While most banks display this information consistently, some may display it incorrectly or not at all. It must contain at least one letter.')
                        ->end()
                        ->scalarNode('unit_label')
                            ->info('A label that represents units of this product, such as seat(s), in Stripe and on customers’ receipts and invoices. Only available on products of type=service.')
                        ->end()
                    ->end()
                    ->info('The product whose pricing the created plan will represent. This can either be the ID of an existing product, or a dictionary containing fields used to create a service product.')
                ->end()
                ->booleanNode('active')
                    ->info('Whether to immediately capture the charge. When false, the charge issues an authorization (or pre-authorization), and will need to be captured later. Uncaptured charges expire in seven days. For more information, see the authorizing charges and settling later documentation.')
                ->end()
                ->enumNode('aggregate_usage')
                    ->values([Plan::AGGREGATE_USAGE_SUM, Plan::AGGREGATE_USAGE_LAST_DURING_PERIOD, Plan::AGGREGATE_USAGE_LAST_EVER, Plan::AGGREGATE_USAGE_MAX])
                    ->info('Specifies a usage aggregation strategy for plans of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for picking the last usage record reported within a period, last_ever for picking the last usage record ever (across period bounds) or max which picks the usage record with the maximum reported usage during a period. Defaults to sum.')
                ->end()
                ->integerNode('amount')
                    ->info('A positive integer in cents (or 0 for a free plan) representing how much to charge on a recurring basis.')
                ->end()
                ->enumNode('billing_scheme')
                    ->values([Plan::BILLING_SCHEME_PER_UNIT, Plan::BILLING_SCHEME_TIERED])
                    ->info('Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount (specified in amount) will be charged per unit in quantity (for plans with usage_type=licensed), or per unit of total usage (for plans with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.')
                ->end()
                ->integerNode('interval_count')
                    ->info('The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).')
                ->end()
                ->arrayNode('metadata')
                    ->scalarPrototype()->end()
                    ->info('Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata.')
                ->end()
                ->scalarNode('nickname')
                    ->info('A brief description of the plan, hidden from customers.')
                ->end()
                ->arrayNode('tiers')
                    ->children()
                        ->scalarNode('up_to')
                            ->isRequired()
                            ->info('Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use inf to define a fallback tier.')
                        ->end()
                        ->integerNode('flat_amount')
                            ->info('The flat billing amount for an entire tier, regardless of the number of units in the tier.')
                        ->end()
                        ->integerNode('unit_amount')
                            ->info('The per unit billing amount for each individual unit for which this tier applies.')
                        ->end()
                    ->end()
                    ->info('Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme. ')
                ->end()
                ->enumNode('tiers_mode')
                    ->values([Plan::TIERS_MODE_GRADUATED, Plan::TIERS_MODE_VOLUME])
                    ->info('Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.')
                ->end()
                ->arrayNode('transform_usage')
                    ->arrayPrototype()
                        ->children()
                            ->integerNode('divide_by')
                                ->isRequired()
                                ->info('Divide usage by this number.')
                            ->end()
                            ->enumNode('round')
                                ->values([Plan::ROUND_UP, Plan::ROUND_DOWN])
                                ->isRequired()
                                ->info('After division, either round the result up or down.')
                            ->end()
                        ->end()
                    ->end()
                    ->info('Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with tiers.')
                ->end()
                ->integerNode('trial_period_days')
                    ->info('Default number of trial days when subscribing a customer to this plan using trial_from_plan=true.')
                ->end()
                ->enumNode('usage_type')
                    ->values([Plan::USAGE_TYPE_METERED, Plan::USAGE_TYPE_LICENSED])
                    ->info('Configures how the quantity per period should be determined, can be either metered or licensed. licensed will automatically bill the quantity set for a plan when adding it to a subscription, metered will aggregate the total usage based on usage records. Defaults to licensed.')
                ->end()
            ->end()
        ;

        $rootNode
            ->validate()
                ->ifTrue(function ($v) {
                    return isset($v['billing_scheme']) && Plan::BILLING_SCHEME_PER_UNIT === $v['billing_scheme'] && !isset($v['amount']);
                })
                ->thenInvalid('"amount" is required when using  "per_unit" bill scheme.')
            ->end()
            ->validate()
                ->ifTrue(function ($v) {
                    return isset($v['billing_scheme']) && Plan::BILLING_SCHEME_TIERED === $v['billing_scheme'] && !isset($v['tiers']);
                })
                ->thenInvalid('"tiers" is required when using  "tiered" bill scheme.')
            ->end()
            ->validate()
                ->ifTrue(function ($v) {
                    return isset($v['tiers']) && (!isset($v['billing_scheme']) || Plan::BILLING_SCHEME_TIERED !== $v['billing_scheme']);
                })
                ->thenInvalid('"tiers" requires using  "tiered" bill scheme.')
            ->end()
            ->validate()
                ->ifTrue(function ($v) {
                    return isset($v['billing_scheme']) && Plan::BILLING_SCHEME_TIERED === $v['billing_scheme'] && !isset($v['tiers_mode']);
                })
                ->thenInvalid('"tiers_mode" is required when using  "tiered" bill scheme.')
            ->end()
            ->validate()
            ->ifTrue(function ($v) {
                return isset($v['tiers']) && isset($v['transform_usage']) && null !== $v['tiers'] && !empty($v['transform_usage']);
            })
                ->thenInvalid('"transform_usage" cannot be combined with "tiers".')
            ->end()
            ->validate()
                ->ifTrue(function ($v) {
                    return !isset($v['existing_product']) && !isset($v['product']);
                })
                ->thenInvalid('You must specify either "existing_product" or "product" node.')
            ->end()
            ->validate()
                ->ifTrue(function ($v) {
                    return isset($v['existing_product']) && isset($v['product']);
                })
                ->thenInvalid('You cannot specify both "existing_product" and "product" node.')
            ->end()
        ;

        return $treeBuilder;
    }
}
